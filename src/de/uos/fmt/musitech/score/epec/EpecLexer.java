/**********************************************

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
<http://www.gnu.org/licenses/>.
In addition to the rights granted to the GNU General Public License,
you opt to use this program as specified in the following:

MUSITECH LINKING EXCEPTION

Linking this library statically or dynamically with other modules is making
a combined work based on this library. Thus, the terms and conditions of the
GNU General Public License cover the whole combination.

As a special exception, the copyright holders of this library give you permission
to link this library with independent modules to produce an executable, regardless
of the license terms of these independent modules, and to copy and distribute the
resulting executable under terms of your choice, provided that you also meet,
for each linked independent module, the terms and conditions of the license of
that module. An independent module is a module which is not derived from or based
on this library.

For the MUSITECH library, this exceptional permission described in the paragraph
above is subject to the following three conditions:
- If you modify this library, you must extend the GNU General Public License and
       this exception including these conditions to your version of the MUSITECH library.
- If you distribute a combined work with this library, you have to mention the
       MUSITECH project and link to its web site www.musitech.org in a location
       easily accessible to the users of the combined work (typically in the "About"
       section of the "Help" menu) and in any advertising material for the combined
       software.
- If you distribute a combined work with the MUSITECH library, you allow the MUSITECH
               project to use mention your combined work for promoting the MUSITECH project.
       For the purpose of this licence, 'distribution' includes the provision of software
       services (e.g. over the World Wide Web).

**********************************************/
/* The following code was generated by JFlex 1.3.5 on 3/2/04 8:49 PM */

// This file must be translated with JFlex (http://www.jflex.de) 
// use option --skel skeleton.nested

package de.uos.fmt.musitech.score.epec;

import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;
import java.util.Stack;


/**
 * This class encapsulates the lexical analyzer that collects the tokens from the input
 * language (Plaine and Easy Code). This class is a scanner generated by <a
 * href="http://www.jflex.de/">JFlex </a> 1.3.5 on 3/2/04 8:49 PM from the specification
 * file
 * <tt>file:/home/collin/Sources/projects/musitech/workspace/musitech/de/uos/fmt/musitech/music/EpecLexer.l</tt>
 * 
 * @author Martin Gieseking
 * @version $Revision: 7766 $, $Date: 2010-03-10 18:53:18 +0100 (Wed, 10 Mar 2010) $
 */
class EpecLexer implements EpecParser.yyInput {

  /** This character denotes the end of file */
  final public static int YYEOF = -1;

  /** initial size of the lookahead buffer */
  final private static int YY_BUFFERSIZE = 16384;

  /** lexical states */
  final public static int include = 2;
  final public static int YYINITIAL = 0;
  final public static int comment = 1;

  /**
   * Translates characters to character classes
   */
  final private static char [] yycmap = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  2,  0,  1,  1,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     3,  0,  4, 10,  0,  0,  0, 30,  0,  0,  5,  0, 31,  8, 32,  6, 
     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  0, 33,  0,  0,  0,  0, 
     0,  0,  0, 27,  0,  0,  0,  0,  0,  0,  0, 28,  0,  0,  0,  0, 
     0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0, 23, 35, 13, 16, 17,  7,  7,  7, 11, 24, 36, 14, 22, 12, 25, 
    20,  0, 21, 26, 19, 15,  0,  0, 18,  0,  0,  0, 34,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
  };

  /**
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = { 
        0,    37,    74,   111,   148,   185,   222,   111,   259,   259, 
      296,   333,   370,   407,   444,   481,   518,   111,   111,   111, 
      555,   592,   629,   666,   703,   740,   777,   814,   148,   851, 
      111,   111,   888,   925,   962,   999,  1036,  1073,  1110,  1147, 
     1184,  1221,   111,   111,   111,  1258,   111,  1295,  1332,  1369, 
     1406,  1443,  1480,  1517,  1554,  1591,  1628,  1665,  1702,   111, 
     1739,  1776,  1813,   111,  1850,   111,  1887,   111,  1924,  1961, 
     1998,   111,  2035,   111,   111,   111,   111,  2072,  2109,  2146, 
     2183,   111,  2220,   111
  };

  /**
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 = 
    "\1\4\3\5\1\4\1\6\1\7\1\10\1\11\1\12"+
    "\1\13\1\4\1\14\1\10\1\15\1\4\1\10\1\16"+
    "\2\4\1\17\1\4\1\20\1\10\2\4\1\21\1\22"+
    "\1\23\1\24\1\25\1\26\1\27\1\30\1\31\1\10"+
    "\1\4\5\32\1\33\1\34\36\32\1\4\1\5\1\35"+
    "\1\5\1\36\1\6\1\7\1\10\1\11\1\12\1\13"+
    "\1\4\1\14\1\10\1\15\1\4\1\10\1\16\2\4"+
    "\1\17\1\4\1\20\1\10\2\4\1\21\1\22\1\23"+
    "\1\24\1\25\1\26\1\27\1\30\1\31\1\10\1\4"+
    "\46\0\3\5\47\0\1\37\43\0\1\40\1\41\47\0"+
    "\1\12\46\0\1\42\62\0\1\43\26\0\1\44\53\0"+
    "\1\45\47\0\1\46\3\0\1\47\26\0\1\50\13\0"+
    "\1\51\40\0\1\52\57\0\1\25\45\0\1\26\45\0"+
    "\1\27\45\0\1\53\45\0\1\54\2\0\5\32\2\0"+
    "\36\32\5\55\1\56\1\57\44\55\1\60\36\55\2\61"+
    "\3\0\40\61\2\41\1\0\42\41\14\0\1\62\57\0"+
    "\1\63\31\0\1\64\43\0\1\65\44\0\1\66\56\0"+
    "\1\67\33\0\1\70\55\0\1\71\2\0\1\72\43\0"+
    "\1\73\15\0\5\55\1\56\1\0\36\55\2\41\1\55"+
    "\3\41\1\60\36\41\2\61\2\0\1\74\40\61\15\0"+
    "\1\75\44\0\1\76\50\0\1\77\46\0\1\100\35\0"+
    "\1\101\53\0\1\102\52\0\1\103\30\0\1\104\60\0"+
    "\1\105\30\0\1\106\45\0\1\107\43\0\1\110\72\0"+
    "\1\111\24\0\1\112\46\0\1\113\44\0\1\114\34\0"+
    "\1\115\46\0\1\116\52\0\1\117\37\0\1\120\45\0"+
    "\1\121\44\0\1\122\52\0\1\123\61\0\1\124";

  /**
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Internal error: unknown state",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {
     0,  0,  0,  9,  1,  1,  1,  9,  1,  1,  1,  1,  1,  1,  1,  1, 
     1,  9,  9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  9,  9, 
     1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  9,  9,  1,  9,  1, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  9, 
     0,  9,  0,  9,  0,  0,  0,  9,  0,  9,  9,  9,  9,  0,  0,  0, 
     0,  9,  0,  9
  };

  /** the input device */
  private java.io.Reader yy_reader;

  /** the current state of the DFA */
  private int yy_state;

  /** the current lexical state */
  private int yy_lexical_state = YYINITIAL;

  /**
   * this buffer contains the current text to be matched and is the source of the yytext()
   * string
   */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int yy_markedPos;

  /** the textposition at the last state to be included in yytext */
  private int yy_pushbackPos;

  /** the current text position in the buffer */
  private int yy_currentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int yy_startRead;

  /**
   * endRead marks the last character in the buffer, that has been read from input
   */
  private int yy_endRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the matched text
   */
  private int yycolumn; 

  /**
   * yy_atBOL == true <=>the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /** yy_atEOF == true <=>the scanner is at the EOF */
  private boolean yy_atEOF;


  /** the stack of open (nested) input streams to read from */
  private java.util.Stack yy_streams = new java.util.Stack();

  /**
   * inner class used to store info for nested input streams
   */
  final private static class YY_StreamInfo {
    java.io.Reader yy_reader;
    int yy_endRead;
    int yy_startRead;
    int yy_currentPos;
    int yy_markedPos;
    int yy_pushbackPos;
    int yyline;
    int yycolumn;
    char [] yy_buffer;
    boolean yy_atEOF;

    /** sets all values stored in this class */
    YY_StreamInfo(java.io.Reader yy_reader, int yy_endRead, int yy_startRead,
                  int yy_currentPos, int yy_markedPos, int yy_pushbackPos,
                  char [] yy_buffer, boolean yy_atEOF, int yyline, int yycolumn) {
      this.yy_reader      = yy_reader;
      this.yy_endRead     = yy_endRead;
      this.yy_startRead   = yy_startRead;
      this.yy_currentPos  = yy_currentPos;
      this.yy_markedPos   = yy_markedPos;
      this.yy_pushbackPos = yy_pushbackPos;
      this.yy_buffer      = yy_buffer;
      this.yy_atEOF       = yy_atEOF;
      this.yyline         = yyline;
      this.yycolumn       = yycolumn;
    }
  }

  /** denotes if the user-EOF-code has already been executed */
  private boolean yy_eof_done;

  /* user code: */
   private int    token;      
   private Object value;        // semantic value of recognized token
   //private int commentCount = 0;
   private Stack  includeStack = new Stack(); // stores the included filenames
   
   @Override
public boolean advance () throws java.io.IOException 
   {
      token = yylex();
      return token != YYEOF; // gets true if reached end of input stream
   }

   @Override
public int token ()    {return token;}   
   @Override
public Object value () {return value;}    
   public int line ()     {return yyline+1;}
   public int column ()   {return yycolumn+1;}

   public void printErrorMessage (String message)
   {
      System.out.println("error at line "+line()+", col "+column()+": "+message);
   }

   public void printWarningMessage (String message)
   {
      System.out.println("warning at line "+line()+", col "+column()+": "+message);
   }
   
   // @@ todo: first file (if available) must be pushed on the include stack
   private void includeFile (String fname)
   {
//      System.out.println("trying to include file "+fname);
      boolean ok = true;
      Iterator it = includeStack.iterator();
      while (it.hasNext() && ok)
         ok = !((String)it.next()).equals(fname);
      if (!ok)
         printWarningMessage("file \"" + fname + "\" already included (skipping)");
      else
      {
         try {
            yypushStream(new FileReader(fname));         
            includeStack.push(fname);
         }
         catch (IOException e) {         
            printErrorMessage("file \"" + fname + "\" not found");
         }
      }
   }

   private boolean leaveIncludeFile ()
   {
      if (!yymoreStreams())
         return false;
      try {
         yypopStream();
         includeStack.pop();
      }
      catch (IOException e) {
         e.printStackTrace();
      }
      return true;
   }

   private String cutQuotes (String str)
   {      
      return str.substring(1, str.lastIndexOf('"'));   
   }
   


  /**
   * Creates a new scanner There is also a java.io.InputStream version of this
   * constructor.
   * 
   * @param in
   *            the java.io.Reader to read input from.
   */
  EpecLexer(java.io.Reader in) {
    this.yy_reader = in;
  }

  /**
   * Creates a new scanner. There is also java.io.Reader version of this constructor.
   * 
   * @param in
   *            the java.io.Inputstream to read input from.
   */
  EpecLexer(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /**
   * Unpacks the split, compressed DFA transition table.
   * 
   * @return the unpacked transition table
   */
  private static int [] yy_unpack() {
    int [] trans = new int[2257];
    int offset = 0;
    offset = yy_unpack(yy_packed0, offset, trans);
    return trans;
  }

  /**
   * Unpacks the compressed DFA transition table.
   * 
   * @param packed
   *            the packed transition table
   * @return the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int [] trans) {
    int i = 0;       /* index in packed string */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do trans[j++] = value; while (--count > 0);
    }
    return j;
  }


  /**
   * Refills the input buffer.
   * 
   * @return <code>false</code>, iff there was new input.
   * 
   * @exception IOException
   *                if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (yy_startRead > 0) {
      System.arraycopy(yy_buffer, yy_startRead, 
                       yy_buffer, 0, 
                       yy_endRead-yy_startRead);

      /* translate stored positions */
      yy_endRead-= yy_startRead;
      yy_currentPos-= yy_startRead;
      yy_markedPos-= yy_startRead;
      yy_pushbackPos-= yy_startRead;
      yy_startRead = 0;
    }

    /* is the buffer big enough? */
    if (yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[yy_currentPos*2];
      System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
      yy_buffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = yy_reader.read(yy_buffer, yy_endRead, 
                                            yy_buffer.length-yy_endRead);

    if (numRead < 0) {
      return true;
    }
    else {
      yy_endRead+= numRead;  
      return false;
    }
  }

    
  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
    yy_atEOF = true;            /* indicate end of file */
    yy_endRead = yy_startRead;  /* invalidate buffer */

    if (yy_reader != null)
      yy_reader.close();
  }


  /**
   * Stores the current input stream on a stack, and reads from a new stream. Lexical
   * state, line, char, and column counting remain untouched.
   * 
   * The current input stream can be restored with yypopstream (usually in an <<EOF>>
   * action).
   * 
   * @param reader
   *            the new input stream to read from
   * 
   * @see #yypopStream()
   */
  final public void yypushStream(java.io.Reader reader) {
    yy_streams.push(
      new YY_StreamInfo(yy_reader, yy_endRead, yy_startRead, yy_currentPos,
                        yy_markedPos, yy_pushbackPos, yy_buffer, yy_atEOF,
                        yyline, yycolumn)
    );
    yy_atEOF  = false;  
    yy_buffer = new char[YY_BUFFERSIZE]; 
    yy_reader = reader;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yycolumn = 0;
  }
    

  /**
   * Closes the current input stream and continues to read from the one on top of the
   * stream stack.
   * 
   * @throws java.util.EmptyStackException
   *             if there is no further stream to read from.
   * 
   * @throws java.io.IOException
   *             if there was an error in closing the stream.
   * 
   * @see #yypushStream(java.io.Reader)
   */
  final public void yypopStream() throws java.io.IOException {
    yy_reader.close();
    YY_StreamInfo s = (YY_StreamInfo) yy_streams.pop();
    yy_buffer      = s.yy_buffer;
    yy_reader      = s.yy_reader;
    yy_endRead     = s.yy_endRead;
    yy_startRead   = s.yy_startRead;
    yy_currentPos  = s.yy_currentPos;
    yy_markedPos   = s.yy_markedPos ;
    yy_pushbackPos = s.yy_pushbackPos;
    yy_atEOF       = s.yy_atEOF;
    yyline         = s.yyline;
    yycolumn       = s.yycolumn;
  }


  /**
   * Returns true iff there are still streams left to read from on the stream stack.
   */
  final public boolean yymoreStreams() {
    return !yy_streams.isEmpty();
  }


  /**
   * Closes the current stream, and resets the scanner to read from a new input stream.
   * 
   * All internal variables are reset, the old input stream <b>cannot </b> be reused
   * (internal buffer is discarded and lost). Lexical state is set to <tt>YY_INITIAL</tt>.
   * 
   * @param reader
   *            the new input stream
   * 
   * @see #yypushStream(java.io.Reader)
   * @see #yypopStream()
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
    yyclose();
    yy_reader = reader;
    yy_atBOL  = true;
    yy_atEOF  = false;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yychar = yycolumn = 0;
    yy_lexical_state = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
    return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   * 
   * @param newState
   *            the new lexical state
   */
  final public void yybegin(int newState) {
    yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
    return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the matched text.
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   * 
   * @param pos
   *            the position of the character to fetch. A value from 0 to yylength()-1.
   * 
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
    return yy_buffer[yy_startRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
    return yy_markedPos-yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   * 
   * In a wellformed scanner (no or only correct usage of yypushback(int) and a match-all
   * fallback rule) this method will only be called with things that "Can't Possibly
   * Happen". If this method is called, something is seriously wrong (e.g. a JFlex bug
   * producing a faulty scanner etc.).
   * 
   * Usual syntax/scanner level error handling should be done in error fallback rules.
   * 
   * @param errorCode
   *            the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
    String message;
    try {
      message = YY_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   * 
   * They will be read again by then next call of the scanning method
   * 
   * @param number
   *            the number of characters to be read again. This number must not be greater
   *            than yylength()!
   */
  private void yypushback(int number)  {
    if ( number > yylength() )
      yy_ScanError(YY_PUSHBACK_2BIG);

    yy_markedPos -= number;
  }


  /**
   * Contains user EOF-code, which will be executed exactly once, when the end of file is
   * reached
   */
  private void yy_do_eof() throws java.io.IOException {
    if (!yy_eof_done) {
      yy_eof_done = true;
      yyclose();
    }
  }


  /**
   * Resumes scanning until the next regular expression is matched, the end of input is
   * encountered or an I/O-Error occurs.
   * 
   * @return the next token
   * @exception IOException
   *                if any I/O-Error occurs
   */
  public int yylex() throws java.io.IOException {
    int yy_input;
    int yy_action;

    // cached fields:
    int yy_currentPos_l;
    int yy_startRead_l;
    int yy_markedPos_l;
    int yy_endRead_l = yy_endRead;
    char [] yy_buffer_l = yy_buffer;
    char [] yycmap_l = yycmap;

    int [] yytrans_l = yytrans;
    int [] yy_rowMap_l = yy_rowMap;
    byte [] yy_attr_l = YY_ATTRIBUTE;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      boolean yy_r = false;
      for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                                                             yy_currentPos_l++) {
        switch (yy_buffer_l[yy_currentPos_l]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          yycolumn = 0;
          yy_r = false;
          break;
        case '\r':
          yyline++;
          yycolumn = 0;
          yy_r = true;
          break;
        case '\n':
          if (yy_r)
            yy_r = false;
          else {
            yyline++;
            yycolumn = 0;
          }
          break;
        default:
          yy_r = false;
          yycolumn++;
        }
      }

      if (yy_r) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean yy_peek;
        if (yy_markedPos_l < yy_endRead_l)
          yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        else if (yy_atEOF)
          yy_peek = false;
        else {
          boolean eof = yy_refill();
          yy_markedPos_l = yy_markedPos;
          yy_buffer_l = yy_buffer;
          if (eof) 
            yy_peek = false;
          else 
            yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        }
        if (yy_peek) yyline--;
      }
      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos = 
                       yy_startRead = yy_markedPos_l;
  
      yy_state = yy_lexical_state;


      yy_forAction: {
        while (true) {
    
          if (yy_currentPos_l < yy_endRead_l)
            yy_input = yy_buffer_l[yy_currentPos_l++];
          else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          }
          else {
            // store back cached positions
            yy_currentPos  = yy_currentPos_l;
            yy_markedPos   = yy_markedPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l  = yy_currentPos;
            yy_markedPos_l   = yy_markedPos;
            yy_buffer_l      = yy_buffer;
            yy_endRead_l     = yy_endRead;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            }
            else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
          int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
          if (yy_next == -1) break yy_forAction;
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ( (yy_attributes & 1) == 1 ) {
            yy_action = yy_state; 
            yy_markedPos_l = yy_currentPos_l; 
            if ( (yy_attributes & 8) == 8 ) break yy_forAction;
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      switch (yy_action) {

        case 83: 
          { value = null; return EpecParser.LINEBREAK; }
        case 85: break;
        case 22: 
          { value = new Integer(yytext().length());  return EpecParser.DOT_SEQ; }
        case 86: break;
        case 17: 
          { value = null; return EpecParser.CLEF; }
        case 87: break;
        case 18: 
          { value = null; return EpecParser.KEYSIGNATURE; }
        case 88: break;
        case 7: 
        case 13: 
          { value = new Character(yytext().charAt(0)); return EpecParser.BASEPITCH; }
        case 89: break;
        case 28: 
          { printErrorMessage("include filename expected"); }
        case 90: break;
        case 76: 
          { return EpecParser.STACCATO; }
        case 91: break;
        case 73: 
          { value = null; return EpecParser.PRINT; }
        case 92: break;
        case 71: 
          { return EpecParser.NOACCENT; }
        case 93: break;
        case 67: 
          { return EpecParser.MARCATO; }
        case 94: break;
        case 65: 
          { return EpecParser.PORTATO; }
        case 95: break;
        case 81: 
          { yybegin(include); }
        case 96: break;
        case 59: 
          { includeFile(cutQuotes(yytext())); yybegin(YYINITIAL); }
        case 97: break;
        case 30: 
          { printWarningMessage("no corresponding /* found (skipping)"); }
        case 98: break;
        case 20: 
          { value = new Integer(yytext().length()-1);  return EpecParser.AP_SEQ; }
        case 99: break;
        case 21: 
          { value = new Integer(-yytext().length());  return EpecParser.COLON_SEQ; }
        case 100: break;
        case 31: 
          { yybegin(comment); }
        case 101: break;
        case 19: 
          { value = null; return EpecParser.TIMESIGNATURE; }
        case 102: break;
        case 46: 
          { yybegin(YYINITIAL); }
        case 103: break;
        case 9: 
          { value = new Integer(yytext()); return EpecParser.INTEGER; }
        case 104: break;
        case 63: 
          { value = null; return YYEOF; }
        case 105: break;
        case 43: 
          { value = null; return EpecParser.BARLINE; }
        case 106: break;
        case 42: 
          { value = null; return EpecParser.STAFFSEP; }
        case 107: break;
        case 3: 
        case 5: 
        case 6: 
        case 8: 
        case 10: 
        case 11: 
        case 12: 
        case 14: 
        case 15: 
        case 16: 
        case 26: 
        case 27: 
        case 29: 
          { value = null; return yytext().charAt(0); }
        case 108: break;
        case 23: 
          { value = null; return EpecParser.VOICESEP; }
        case 109: break;
        case 24: 
          { value = null; return EpecParser.BARLINE; }
        case 110: break;
        case 75: 
          { value = "major"; return EpecParser.MODE; }
        case 111: break;
        case 74: 
          { value = "minor"; return EpecParser.MODE; }
        case 112: break;
        case 47: 
          {  }
        case 113: break;
        case 44: 
        case 45: 
          {  }
        case 114: break;
        case 4: 
          {  }
        case 115: break;
        case 25: 
          {  }
        case 116: break;
        case 32: 
          {  }
        case 117: break;
        default: 
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            yy_do_eof();
            switch (yy_lexical_state) {
            case comment:
              { printErrorMessage("missing '*/' at end of file"); yybegin(YYINITIAL); }
            case 85: break;
            default:
              { if (!leaveIncludeFile()) return YYEOF; }
            }
          } 
          else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }


}
