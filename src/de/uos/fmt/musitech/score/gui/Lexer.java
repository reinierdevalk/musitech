/**********************************************

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
<http://www.gnu.org/licenses/>.
In addition to the rights granted to the GNU General Public License,
you opt to use this program as specified in the following:

MUSITECH LINKING EXCEPTION

Linking this library statically or dynamically with other modules is making
a combined work based on this library. Thus, the terms and conditions of the
GNU General Public License cover the whole combination.

As a special exception, the copyright holders of this library give you permission
to link this library with independent modules to produce an executable, regardless
of the license terms of these independent modules, and to copy and distribute the
resulting executable under terms of your choice, provided that you also meet,
for each linked independent module, the terms and conditions of the license of
that module. An independent module is a module which is not derived from or based
on this library.

For the MUSITECH library, this exceptional permission described in the paragraph
above is subject to the following three conditions:
- If you modify this library, you must extend the GNU General Public License and
       this exception including these conditions to your version of the MUSITECH library.
- If you distribute a combined work with this library, you have to mention the
       MUSITECH project and link to its web site www.musitech.org in a location
       easily accessible to the users of the combined work (typically in the "About"
       section of the "Help" menu) and in any advertising material for the combined
       software.
- If you distribute a combined work with the MUSITECH library, you allow the MUSITECH
               project to use mention your combined work for promoting the MUSITECH project.
       For the purpose of this licence, 'distribution' includes the provision of software
       services (e.g. over the World Wide Web).

**********************************************/
/* The following code was generated by JFlex 1.3.5 on 5/12/03 10:28 AM */

// This file must be translated with JFlex (http://www.jflex.de) 
// use option --skel skeleton.nested

package de.uos.fmt.musitech.score.gui;

import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;
import java.util.Stack;


/** This class encapsulates the lexical analyzer that collects the tokens 
    from the input language (Plaine and Easy Code).
    @author Martin Gieseking
    @version $Revision: 7766 $, $Date: 2010-03-10 18:53:18 +0100 (Wed, 10 Mar 2010) $ */

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 5/12/03 10:28 AM from the specification file
 * <tt>file:/home/collin/Sources/projects/musitech/workspace/musitech/de/uos/fmt/musitech/gin/Lexer.l</tt>
 */
class Lexer implements Parser.yyInput {

  /** This character denotes the end of file */
  final public static int YYEOF = -1;

  /** initial size of the lookahead buffer */
  final private static int YY_BUFFERSIZE = 16384;

  /** lexical states */
  final public static int include = 2;
  final public static int YYINITIAL = 0;
  final public static int comment = 1;

  /** 
   * Translates characters to character classes
   */
  final private static char [] yycmap = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  2,  0,  1,  1,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     3,  0,  4, 10,  0,  0,  0, 30,  0,  0,  5,  0, 31,  8, 32,  6, 
     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  0, 33,  0,  0,  0,  0, 
     0,  0,  0, 27,  0,  0,  0,  0,  0,  0,  0, 28,  0,  0,  0,  0, 
     0,  0,  0,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0, 23,  7, 13, 16, 17,  7,  7,  7, 11, 24,  0, 14, 22, 12, 25, 
    20,  0, 21, 26, 19, 15,  0,  0, 18,  0,  0,  0, 34,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
  };

  /** 
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = { 
        0,    35,    70,   105,   140,   175,   210,   105,   245,   245, 
      280,   315,   350,   385,   420,   455,   105,   105,   105,   490, 
      525,   560,   595,   630,   665,   700,   735,   140,   770,   105, 
      105,   805,   840,   875,   910,   945,   980,  1015,  1050,  1085, 
      105,   105,   105,  1120,   105,  1155,  1190,  1225,  1260,  1295, 
     1330,  1365,  1400,  1435,  1470,  1505,   105,  1540,  1575,   105, 
     1610,   105,  1645,   105,  1680,  1715,  1750,   105,   105,   105, 
      105,   105,  1785,  1820,   105
  };

  /** 
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 = 
    "\1\4\3\5\1\4\1\6\1\7\1\10\1\11\1\12"+
    "\1\13\1\4\1\14\1\10\2\4\1\10\1\15\2\4"+
    "\1\16\1\4\1\17\1\10\2\4\1\20\1\21\1\22"+
    "\1\23\1\24\1\25\1\26\1\27\1\30\5\31\1\32"+
    "\1\33\34\31\1\4\1\5\1\34\1\5\1\35\1\6"+
    "\1\7\1\10\1\11\1\12\1\13\1\4\1\14\1\10"+
    "\2\4\1\10\1\15\2\4\1\16\1\4\1\17\1\10"+
    "\2\4\1\20\1\21\1\22\1\23\1\24\1\25\1\26"+
    "\1\27\1\30\44\0\3\5\45\0\1\36\41\0\1\37"+
    "\1\40\45\0\1\12\44\0\1\41\60\0\1\42\33\0"+
    "\1\43\45\0\1\44\3\0\1\45\24\0\1\46\13\0"+
    "\1\47\36\0\1\50\55\0\1\24\43\0\1\25\43\0"+
    "\1\26\43\0\1\51\43\0\1\52\5\31\2\0\34\31"+
    "\5\53\1\54\1\55\42\53\1\56\34\53\2\57\3\0"+
    "\36\57\2\40\1\0\40\40\14\0\1\60\55\0\1\61"+
    "\26\0\1\62\42\0\1\63\54\0\1\64\31\0\1\65"+
    "\53\0\1\66\2\0\1\67\41\0\1\70\13\0\5\53"+
    "\1\54\1\0\34\53\2\40\1\53\3\40\1\56\34\40"+
    "\2\57\2\0\1\71\36\57\15\0\1\72\42\0\1\73"+
    "\50\0\1\74\33\0\1\75\51\0\1\76\50\0\1\77"+
    "\26\0\1\100\56\0\1\101\26\0\1\102\43\0\1\103"+
    "\41\0\1\104\50\0\1\105\44\0\1\106\42\0\1\107"+
    "\32\0\1\110\44\0\1\111\43\0\1\112\43\0\1\113"+
    "\21\0";

  /** 
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Internal error: unknown state",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {
     0,  0,  0,  9,  1,  1,  1,  9,  1,  1,  1,  1,  1,  1,  1,  1, 
     9,  9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  9,  9,  1, 
     0,  0,  0,  0,  0,  0,  0,  0,  9,  9,  9,  1,  9,  1,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  9,  0,  9,  0,  9, 
     0,  0,  0,  9,  9,  9,  9,  9,  0,  0,  9
  };

  /** the input device */
  private java.io.Reader yy_reader;

  /** the current state of the DFA */
  private int yy_state;

  /** the current lexical state */
  private int yy_lexical_state = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int yy_markedPos;

  /** the textposition at the last state to be included in yytext */
  private int yy_pushbackPos;

  /** the current text position in the buffer */
  private int yy_currentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int yy_startRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int yy_endRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn; 

  /** 
   * yy_atBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /** yy_atEOF == true <=> the scanner is at the EOF */
  private boolean yy_atEOF;


  /** the stack of open (nested) input streams to read from */
  private java.util.Stack yy_streams = new java.util.Stack();

  /**
   * inner class used to store info for nested
   * input streams
   */
  final private static class YY_StreamInfo {
    java.io.Reader yy_reader;
    int yy_endRead;
    int yy_startRead;
    int yy_currentPos;
    int yy_markedPos;
    int yy_pushbackPos;
    int yyline;
    int yycolumn;
    char [] yy_buffer;
    boolean yy_atEOF;

    /** sets all values stored in this class */
    YY_StreamInfo(java.io.Reader yy_reader, int yy_endRead, int yy_startRead,
                  int yy_currentPos, int yy_markedPos, int yy_pushbackPos,
                  char [] yy_buffer, boolean yy_atEOF, int yyline, int yycolumn) {
      this.yy_reader      = yy_reader;
      this.yy_endRead     = yy_endRead;
      this.yy_startRead   = yy_startRead;
      this.yy_currentPos  = yy_currentPos;
      this.yy_markedPos   = yy_markedPos;
      this.yy_pushbackPos = yy_pushbackPos;
      this.yy_buffer      = yy_buffer;
      this.yy_atEOF       = yy_atEOF;
      this.yyline         = yyline;
      this.yycolumn       = yycolumn;
    }
  }

  /** denotes if the user-EOF-code has already been executed */
  private boolean yy_eof_done;

  /* user code: */
   private int    token;      
   private Object value;        // semantic value of recognized token
   //private int    commentCount = 0;
   private Stack  includeStack = new Stack(); // stores the included filenames
   
   public boolean advance () throws java.io.IOException 
   {
      token = yylex();
      return token != YYEOF; // gets true if reached end of input stream
   }

   public int token ()    {return token;}   
   public Object value () {return value;}    
   public int line ()     {return yyline+1;}
   public int column ()   {return yycolumn+1;}

   public void printErrorMessage (String message)
   {
      System.out.println("error at line "+line()+", col "+column()+": "+message);
   }

   public void printWarningMessage (String message)
   {
      System.out.println("warning at line "+line()+", col "+column()+": "+message);
   }
   
   // @@ todo: first file (if available) must be pushed on the include stack     
   private void includeFile (String fname)
   {
//      System.out.println("trying to include file "+fname);
      boolean ok = true;
      Iterator it = includeStack.iterator();
      while (it.hasNext() && ok)
         ok = !((String)it.next()).equals(fname);
      if (!ok)
         printWarningMessage("file \"" + fname + "\" already included (skipping)");
      else
      {
         try {
            yypushStream(new FileReader(fname));         
            includeStack.push(fname);
         }
         catch (IOException e) {         
            printErrorMessage("file \"" + fname + "\" not found");
         }
      }
   }

   private boolean leaveIncludeFile ()
   {
      if (!yymoreStreams())
         return false;
      try {
         yypopStream();
         includeStack.pop();
      }
      catch (IOException e) {
         e.printStackTrace();
      }
      return true;
   }

   private String cutQuotes (String str)
   {      
      return str.substring(1, str.lastIndexOf('"'));   
   }
   


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  Lexer(java.io.Reader in) {
    this.yy_reader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  Lexer(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the split, compressed DFA transition table.
   *
   * @return the unpacked transition table
   */
  private static int [] yy_unpack() {
    int [] trans = new int[1855];
    int offset = 0;
    offset = yy_unpack(yy_packed0, offset, trans);
    return trans;
  }

  /** 
   * Unpacks the compressed DFA transition table.
   *
   * @param packed   the packed transition table
   * @return         the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int [] trans) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do trans[j++] = value; while (--count > 0);
    }
    return j;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   IOException  if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (yy_startRead > 0) {
      System.arraycopy(yy_buffer, yy_startRead, 
                       yy_buffer, 0, 
                       yy_endRead-yy_startRead);

      /* translate stored positions */
      yy_endRead-= yy_startRead;
      yy_currentPos-= yy_startRead;
      yy_markedPos-= yy_startRead;
      yy_pushbackPos-= yy_startRead;
      yy_startRead = 0;
    }

    /* is the buffer big enough? */
    if (yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[yy_currentPos*2];
      System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
      yy_buffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = yy_reader.read(yy_buffer, yy_endRead, 
                                            yy_buffer.length-yy_endRead);

    if (numRead < 0) {
      return true;
    }
    else {
      yy_endRead+= numRead;  
      return false;
    }
  }

    
  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
    yy_atEOF = true;            /* indicate end of file */
    yy_endRead = yy_startRead;  /* invalidate buffer    */

    if (yy_reader != null)
      yy_reader.close();
  }


  /**
   * Stores the current input stream on a stack, and
   * reads from a new stream. Lexical state, line,
   * char, and column counting remain untouched.
   *
   * The current input stream can be restored with
   * yypopstream (usually in an <<EOF>> action).
   *
   * @param reader the new input stream to read from
   *
   * @see #yypopStream()
   */
  final public void yypushStream(java.io.Reader reader) {
    yy_streams.push(
      new YY_StreamInfo(yy_reader, yy_endRead, yy_startRead, yy_currentPos,
                        yy_markedPos, yy_pushbackPos, yy_buffer, yy_atEOF,
                        yyline, yycolumn)
    );
    yy_atEOF  = false;  
    yy_buffer = new char[YY_BUFFERSIZE]; 
    yy_reader = reader;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yycolumn = 0;
  }
    

  /**
   * Closes the current input stream and continues to
   * read from the one on top of the stream stack. 
   *
   * @throws java.util.EmptyStackException
   *         if there is no further stream to read from.
   *
   * @throws java.io.IOException
   *         if there was an error in closing the stream.
   *
   * @see #yypushStream(java.io.Reader)
   */
  final public void yypopStream() throws java.io.IOException {
    yy_reader.close();
    YY_StreamInfo s = (YY_StreamInfo) yy_streams.pop();
    yy_buffer      = s.yy_buffer;
    yy_reader      = s.yy_reader;
    yy_endRead     = s.yy_endRead;
    yy_startRead   = s.yy_startRead;
    yy_currentPos  = s.yy_currentPos;
    yy_markedPos   = s.yy_markedPos ;
    yy_pushbackPos = s.yy_pushbackPos;
    yy_atEOF       = s.yy_atEOF;
    yyline         = s.yyline;
    yycolumn       = s.yycolumn;
  }


  /**
   * Returns true iff there are still streams left 
   * to read from on the stream stack.
   */
  final public boolean yymoreStreams() {
    return !yy_streams.isEmpty();
  }


  /**
   * Closes the current stream, and resets the
   * scanner to read from a new input stream.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>YY_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   *
   * @see #yypushStream(java.io.Reader)
   * @see #yypopStream()
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
    yyclose();
    yy_reader = reader;
    yy_atBOL  = true;
    yy_atEOF  = false;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yychar = yycolumn = 0;
    yy_lexical_state = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
    return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  final public void yybegin(int newState) {
    yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
    return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
    return yy_buffer[yy_startRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
    return yy_markedPos-yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
    String message;
    try {
      message = YY_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  private void yypushback(int number)  {
    if ( number > yylength() )
      yy_ScanError(YY_PUSHBACK_2BIG);

    yy_markedPos -= number;
  }


  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  private void yy_do_eof() throws java.io.IOException {
    if (!yy_eof_done) {
      yy_eof_done = true;
      yyclose();
    }
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   IOException  if any I/O-Error occurs
   */
  public int yylex() throws java.io.IOException {
    int yy_input;
    int yy_action;

    // cached fields:
    int yy_currentPos_l;
    int yy_startRead_l;
    int yy_markedPos_l;
    int yy_endRead_l = yy_endRead;
    char [] yy_buffer_l = yy_buffer;
    char [] yycmap_l = yycmap;

    int [] yytrans_l = yytrans;
    int [] yy_rowMap_l = yy_rowMap;
    byte [] yy_attr_l = YY_ATTRIBUTE;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      boolean yy_r = false;
      for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                                                             yy_currentPos_l++) {
        switch (yy_buffer_l[yy_currentPos_l]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          yycolumn = 0;
          yy_r = false;
          break;
        case '\r':
          yyline++;
          yycolumn = 0;
          yy_r = true;
          break;
        case '\n':
          if (yy_r)
            yy_r = false;
          else {
            yyline++;
            yycolumn = 0;
          }
          break;
        default:
          yy_r = false;
          yycolumn++;
        }
      }

      if (yy_r) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean yy_peek;
        if (yy_markedPos_l < yy_endRead_l)
          yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        else if (yy_atEOF)
          yy_peek = false;
        else {
          boolean eof = yy_refill();
          yy_markedPos_l = yy_markedPos;
          yy_buffer_l = yy_buffer;
          if (eof) 
            yy_peek = false;
          else 
            yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        }
        if (yy_peek) yyline--;
      }
      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos = 
                       yy_startRead = yy_markedPos_l;
  
      yy_state = yy_lexical_state;


      yy_forAction: {
        while (true) {
    
          if (yy_currentPos_l < yy_endRead_l)
            yy_input = yy_buffer_l[yy_currentPos_l++];
          else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          }
          else {
            // store back cached positions
            yy_currentPos  = yy_currentPos_l;
            yy_markedPos   = yy_markedPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l  = yy_currentPos;
            yy_markedPos_l   = yy_markedPos;
            yy_buffer_l      = yy_buffer;
            yy_endRead_l     = yy_endRead;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            }
            else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
          int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
          if (yy_next == -1) break yy_forAction;
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ( (yy_attributes & 1) == 1 ) {
            yy_action = yy_state; 
            yy_markedPos_l = yy_currentPos_l; 
            if ( (yy_attributes & 8) == 8 ) break yy_forAction;
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      switch (yy_action) {

        case 16: 
          { value = null; return Parser.CLEF; }
        case 76: break;
        case 40: 
          { value = null; return Parser.STAFFSEP; }
        case 77: break;
        case 22: 
          { value = null; return Parser.VOICESEP; }
        case 78: break;
        case 27: 
          { printErrorMessage("include filename expected"); }
        case 79: break;
        case 21: 
          { value = new Integer(yytext().length());  return Parser.DOT_SEQ; }
        case 80: break;
        case 74: 
          { yybegin(include); }
        case 81: break;
        case 56: 
          { includeFile(cutQuotes(yytext())); yybegin(YYINITIAL); }
        case 82: break;
        case 29: 
          { printWarningMessage("no corresponding /* found (skipping)"); }
        case 83: break;
        case 19: 
          { value = new Integer(yytext().length()-1);  return Parser.AP_SEQ; }
        case 84: break;
        case 20: 
          { value = new Integer(-yytext().length());  return Parser.COLON_SEQ; }
        case 85: break;
        case 30: 
          { yybegin(comment); }
        case 86: break;
        case 70: 
          { value = "major"; return Parser.MODE; }
        case 87: break;
        case 69: 
          { value = "minor"; return Parser.MODE; }
        case 88: break;
        case 71: 
          { return Parser.STACCATO; }
        case 89: break;
        case 67: 
          { return Parser.NOACCENT; }
        case 90: break;
        case 63: 
          { return Parser.MARCATO; }
        case 91: break;
        case 61: 
          { return Parser.PORTATO; }
        case 92: break;
        case 7: 
        case 12: 
          { value = new Character(yytext().charAt(0)); return Parser.BASEPITCH; }
        case 93: break;
        case 44: 
          { yybegin(YYINITIAL); }
        case 94: break;
        case 41: 
          { value = new BarlineDouble(); return Parser.BARLINE; }
        case 95: break;
        case 9: 
          { value = new Integer(yytext()); return Parser.INTEGER; }
        case 96: break;
        case 23: 
          { value = new BarlineSingle(); return Parser.BARLINE; }
        case 97: break;
        case 18: 
          { value = null; return Parser.TIMESIGNATURE; }
        case 98: break;
        case 59: 
          { value = null; return YYEOF; }
        case 99: break;
        case 17: 
          { value = null; return Parser.KEYSIGNATURE; }
        case 100: break;
        case 3: 
        case 5: 
        case 6: 
        case 8: 
        case 10: 
        case 11: 
        case 13: 
        case 14: 
        case 15: 
        case 25: 
        case 26: 
        case 28: 
          { value = null; return yytext().charAt(0); }
        case 101: break;
        case 68: 
          { value = null; return Parser.PRINT; }
        case 102: break;
        case 45: 
          {  }
        case 103: break;
        case 42: 
        case 43: 
          {  }
        case 104: break;
        case 4: 
          {  }
        case 105: break;
        case 24: 
          {  }
        case 106: break;
        case 31: 
          {  }
        case 107: break;
        default: 
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            yy_do_eof();
            switch (yy_lexical_state) {
            case comment:
              { printErrorMessage("missing '*/' at end of file"); yybegin(YYINITIAL); }
            case 76: break;
            default:
              { if (!leaveIncludeFile()) return YYEOF; }
            }
          } 
          else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }


}
